<!--
 * @Date: 2024-06-06
 * @LastEditors: GoKo-Son626
 * @LastEditTime: 2024-07-07
 * @FilePath: \STM32_Study\入门篇\3.串口\串口.md
 * @Description: 串口的学习和编程实践
-->

# 串口

> 内容目录：
> 
       1，数据通信的基础概念（了解）
       2，串口(RS-232)（熟悉）
       3，STM32的USART（熟悉）
       4，HAL库外设初始化MSP回调机制（了解）
       5，HAL库中断回调机制（了解）
       6，USART/UART异步通信配置步骤（掌握）
       7，IO引脚复用功能（掌握）
       8，编程实战：通过串口接收或者发送一个字符（掌握）
       9，解读例程源码：串口实验（熟悉）

#### 1. 数据通信的基础概念（了解）

###### 1. 串行/并行通信

- 串行通讯：数据逐位按顺序依次传输
- 并行通讯：数据各位通过多条线同时传输

| 特点     | 传输速率 | 抗干扰能力 | 通信距离 | IO资源占用 | 成本 |
| -------- | -------- | ---------- | -------- | ---------- | ---- |
| 串行通信 | 较低     | 较强       | 较长     | 较少       | 较低 |
| 并行通信 | 较高     | 较弱       | 较短     | 较多       | 较高 |

###### 2. 单工/半双工/全双工通信

- 单工通信：数据只能沿一个方向传输
- 半双工通信：数据可以沿两个方向传输，但需要分时进行
- 全双工通信：数据可以同时进行双向传输

###### 3. 同步/异步通信

**同步通信和异步通信**
![同步通信和异步通信](Pictures/同步通信和异步通信.png)

- 同步通信：共用同一时钟信号
- 异步通信：没有时钟信号，通过在数据信号中加入起始位和停止位等一些同步信号

###### 4. 波特率

-  比特率：每秒钟传送的比特数，单位bit/s
-  波特率：每秒钟传送的码元数，单位Baud
-  比特率 = 波特率 * log2 M ，M表示每个码元承载的信息量
- 二进制系统中，波特率数值上等于比特率

###### 5. 常见的串行通信接口

![常见的串行通信接口](Pictures/常见的串行通信接口.png)

#### 2. 串口(RS-232)（熟悉）

1. RS-232电平 逻辑1：-15V ~ -3V 逻辑0：+3V ~ +15V
2. COMS电平（3.3V）逻辑1：3.3V 逻辑0：0V
3. TTL电平（5V）逻辑1：5V 逻辑0：0V

- 结论：COMS/TTL电平不能与RS-232电平直接交换信息

#### 3. STM32的USART（熟悉）

> - Universal synchronous asynchronous receiver transmitter，通用同步异步收发器
> - Universal asynchronous receiver transmitter，通用异步收发器

**STM32F1/F4/F7/H7的USART框图简化版**
![STM32F1/F4/F7/H7的USART框图简化版](Pictures/USART框图简化版.png)

F1波特率计算公式:baud = fck/16∗USARTDIV

#### 4. HAL库外设初始化MSP回调机制（了解）

**HAL库外设初始化MSP回调机制**
![HAL库外设初始化MSP回调机制](Pictures/HAL库外设初始化MSP回调机制.png)

#### 5. HAL库中断回调机制（了解）

**HAL库中断回调机制**
![HAL库中断回调机制](Pictures/HAL库中断回调机制.png)

**HAL库中断回调机制 - USART为例（F1）**
![HAL中断回调机制-USART1](Pictures/HAL中断回调机制-USART1.png)

#### 6. USART/UART异步通信配置步骤（掌握）

> 只要你开启了串口时钟，并设置相应IO口的模式，然后配置一下波特率，数据位长度，奇偶校验位等信息，就可以使用了。总结地来说，我们要学会配置USART对应的寄存器就可以使用串口功能了。下面，我们就简单介绍下这几个与串口基本配置直接相关的寄存器。

1. 配置串口工作参数:HAL_UART_Init()

> **函数返回值：**
HAL_StatusTypeDef枚举类型的值，有4个，分别是HAL_OK表示成功，HAL_ERROR表示错误，HAL_BUSY表示忙碌，HAL_TIMEOUT超时。后续遇到该结构体也是一样的。

- HAL_UART_Init()会调用HAL_UART_MspInit()
> 该函数主要实现底层的初始化，事实上这个函数的代码还可以直接放到usart_init函数里面，但是HAL库为了代码的功能分层初始化，定义这个函数方便用户使用。所以我们也按照HAL库的这个结构来初始化外设。这个函数首先是调用if(huart->Instance == USART1)判断是要初始化哪个串口，因为每个串口初始化都会调用HAL_UART_MspInit这个函数，所以需要判断是哪个串口要初始化才做相应的处理。

2. 串口底层初始化:HAL_UART_MspInit(),配置GPIO、NVIC、CLOCK等

   - 即**时钟**和**GPIO**和**NVIC**的初始化

3. 开启串口异步接收中断:HAL_UART_Receive_IT()

4. 设置优先级，使能中断:HAL_NVIC_SetPriority()、 HAL_NVIC_EnableIRQ()

5. 编写中断服务函数:USARTx_IRQHandler()、 UARTx_IRQHandler()

6. 串口数据发送:（**数据寄存器**USART_DR）HAL_UART_Transmit()

#### 7. IO引脚复用功能（掌握）

- 通用：IO端口的输入或输出是由GPIO外设控制，我们称之为通用
- 复用：IO端口的输入或输出是由其它非GPIO外设控制，我们称之为复用

> **通俗理解：电源插座（IO引脚）可以连接不同的电器（功能）。你可以插上电灯（GPIO输出），也可以插上收音机（UART通信），还可以插上其他设备。每次插上不同的设备，你都需要确保插座模式匹配（配置正确的功能）。通过切换插座的模式（配置复用功能），你可以用同一个插座完成多种任务。**

- **AL库关于端口复用相关的代码在STM32F1xx_hal_gpio_ex.h文件中可以找到**

> AFIO寄存器的作用就是复用功能I/O和调试配置的，STM32F103ZET6共有6个AFIO的寄存器，事件控制寄存器AFIO_EVCR、复用重映射和调试I/O配置寄存器AFIO_MAPR、外部中断配置寄存器AFIO_EXTICR1、外部中断配置寄存器AFIO_EXTICR2、外部中断配置寄存器AFIO_EXTICR3和外部中断配置寄存器AFIO_EXTICR4。
> 在对AFIO_MAPR寄存器某些位进行写入实现引脚的重新映射，这时候，复用功能不再映射到它们原始分配上。例如AFIO_MAPR寄存器位2是对USART1的重映射，置0: 没有重映像(TX/PA9，RX/PA10)；置1: 重映像(TX/PB6，RX/PB7)。默认情况下，PA9和PA10是作为串口1的引脚使用，假如PA9和PA10被用作其他地方，但还是需要用到串口1，那么就可以在AFIO_MAPR的位2置1，把串口1的引脚重映射到PB6和PB7。这个串口初始化的过程，就有点变化，需要初始化AFIO时钟，和对AFIO_MAPR的第2位进行置1操作，其他与普通串口配置没有区别。

#### 8. 编程实战：通过串口接收或者发送一个字符（掌握）

**USART初始化函数**
```c
void usart_init(uint32_t baudrate)
{
    /*UART 初始化设置*/
    g_uart1_handle.Instance = USART1;                                       /* USART_UX */
    g_uart1_handle.Init.BaudRate = baudrate;                                  /* 波特率 */
    g_uart1_handle.Init.WordLength = UART_WORDLENGTH_8B;                      /* 字长为8位数据格式 */
    g_uart1_handle.Init.StopBits = UART_STOPBITS_1;                           /* 一个停止位 */
    g_uart1_handle.Init.Parity = UART_PARITY_NONE;                            /* 无奇偶校验位 */
    g_uart1_handle.Init.HwFlowCtl = UART_HWCONTROL_NONE;                      /* 无硬件流控 */
    g_uart1_handle.Init.Mode = UART_MODE_TX_RX;                               /* 收发模式 */
    HAL_UART_Init(&g_uart1_handle);                                           /* HAL_UART_Init()会使能UART1 */

    HAL_UART_Receive_IT(&g_uart1_handle, (uint8_t*)g_rx_buffer, 1);
}
```

**串口MSP回调函数**
```c
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
    GPIO_InitTypeDef gpio_init_struct;
    if(huart->Instance == USART1)
    {
        //1.使能USART1和对应IO时钟
        __HAL_RCC_USART1_CLK_ENABLE();
        __HAL_RCC_GPIOA_CLK_ENABLE();
        //2.初始化IO
        gpio_init_struct.Pin = GPIO_PIN_9;                 
        gpio_init_struct.Mode = GPIO_MODE_AF_PP;            /* 推挽式复用输出 */
        gpio_init_struct.Speed = GPIO_SPEED_FREQ_HIGH;          /* 高速 */
        HAL_GPIO_Init(GPIOA, &gpio_init_struct);       /* 初始化LED0引脚 */

        gpio_init_struct.Pin = GPIO_PIN_10;                 
        gpio_init_struct.Mode = GPIO_MODE_AF_INPUT;            /* 输入 */
        gpio_init_struct.Pull = GPIO_PULLUP;                    /* 上拉 */
        HAL_GPIO_Init(GPIOA, &gpio_init_struct);       /* 初始化LED0引脚 */
        //3.使能USART1中断，设置优先级
        HAL_NVIC_SetPriority(USART1_IRQn, 3, 3);
        HAL_NVIC_EnableIRQ(USART1_IRQn);

    }
}
```

**串口1中断服务函数**
```c
void USART1_IRQHandler(void)
{
    HAL_UART_IRQHandler(&g_uart1_handle);
    HAL_UART_Receive_IT(&g_uart1_handle, (uint8_t*)g_rx_buffer, 1);
}
```

**回调函数**
```c
void HAL_UART_RxCpltCallback(UART_HandleTypeDef *huart)
{
     g_usart1_rx_flag = 1;
}
```
#### 9. 解读例程源码：串口实验（熟悉）

**串口发送和接收数据过程**
![串口发送数据过程](Pictures/串口发送数据过程.png)
![串口接收数据过程](Pictures/串口接收数据过程.png)